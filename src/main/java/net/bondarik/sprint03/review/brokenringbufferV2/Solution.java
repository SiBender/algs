// https://contest.yandex.ru/contest/23815/run-report/153640488/

/**
 -- ПРИНЦИП РАБОТЫ --
 Условие задачи означает, что полученный массив чисел выглядит как на приложенном рисунке

 Алгоритм использует принцип бинарного поиска
 На каждом шаге цикла диапазон поиска уменьшается в 2 раза
 Но для того, чтобы понять в какую сторону смещать окно поиска
 вводятся дополнительные условия, учитывающие:
    - значения на краях массива
    - искомое k больше или меньше крайних значений
    - сравнение значения в середине отрезка с искомым k и с крайними значениями в массиве

 -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
 При чтении слева направо значения будут расти (не убывать) до некоторого максимума
 Сразу за максимумом идет минимальный элемент, и после этого значения продолжают нарастать (не убывать)

 Поиск максимума накладывает дополнительные затраты по времени (O(log(n))). Можно отказаться от этой идеи

 Назовем участок от начала массива до максимального элемента         Левой частью
 Соответственно, участок от минимального элемента до конца массива - Правой частью.

 При запросе числа k мы можем понять в какой из частей нужно производить поиск
 если k <= последнего элемента, то Правая часть, иначе Левая часть

 Допустим, k оказался в Левой части

 запускаем бинарный поиск. левый и правй указатель на краях массива.
 Вычисляем значение в середине.

 Оно может попасть в Лувую часть, а может и в Правую. Это проверяется так же сравнением с крайним правым элементом

 Если середина оказалась в правой части (middleValue < lastElementValue), значит k не может находиться правее этой точки
 Смещаем ПРАВЫЙ указатель на среднюю точку и повторяем поиск

 Если середина оказалась в Левой части, то нужно сравнить с k.
 Тут возможны 2 варианта:
  1) middleValue < k -> искомый элемент правее середины. Смещаем ЛЕВЫЙ указатель
  2) middleValue > k -> искомый элемент левее середины. Смещаем ПРАВЫЙ указатель


 По такой логике рассчитывается поведение для всех возможных сочетаний условий
  1) k >= lastElementValue ? true : false
  2) middleValue >= lastElementValue ? true : false
  3) middleValue > k ? true : false

 Корректность алгоритма основана на том, что учтены все 6 возможных ситуаций.

 Диапазон поиска ВСЕГДА полуинтервал.
 Поэтому искомый элемент всегда либо в середине интервала, либо на левой границе.
 Это важное условие для корректной работы в случае когда k не присутствует в исходном массиве

 -- ВРЕМЕННАЯ СЛОЖНОСТЬ --

 На каждом шаге цикла происходит 1 обращение к элементу массива по индексу - O(1)
 3 операции сравнения и одно арифметическое действие - O(1)
 В конце итерации диапазон поиска уменьшается в 2 раза.

 То есть максимальное число итераций поиска log(n)

 Итого
 O(1) + O(1) + O(log(n)) = O(log(n))

 -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

 Алгоритм выделяет дополнительную память только для нескольких переменных.

 Пространственная сложность константа O(1)

 */

package net.bondarik.sprint03.review.brokenringbufferV2;

public class Solution {
    public static int brokenSearch(int[] arr, int k) {
        int lastElementValue = arr[arr.length - 1];

        int leftBorder = 0;
        int rightBorder = arr.length;
        int middle = 0;

        while (rightBorder - leftBorder > 1) {
            middle = (leftBorder + rightBorder) / 2;
            int middleValue = arr[middle];

            if (middleValue == k) {
                return middle;
            }

            if (k <= lastElementValue) { //ищем в правой части массива
                if (middleValue <= lastElementValue) {
                    if (middleValue > k) {
                        rightBorder = middle;
                    } else {
                        leftBorder = middle;
                    }
                } else {
                    leftBorder = middle;
                }
            } else { //ищем в левой части массива. k >= firstElementValue
                if (middleValue <= lastElementValue) {
                    rightBorder = middle;
                } else {
                    if (middleValue > k) {
                        rightBorder = middle;
                    } else {
                        leftBorder = middle;
                    }
                }
            }
        }

        return arr[leftBorder] == k ? leftBorder : -1;
    }

    private static void test() {
        int[] arr = {19, 21, 100, 101, 1, 4, 5, 7, 12};
        assert 6 == brokenSearch(arr, 5);
    }

}